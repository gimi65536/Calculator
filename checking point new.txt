001 運算子分為非指派運算子與指派運算子。非指派運算子有+-*/%()=，皆為單字元。+-兩運算子有「加減」與「正負」雙重涵義，在檢查階段不區分。指派運算子有= += -= *= /= %=，其中+= -= *= /= %=為雙字元指派運算子，必須連在一起不得有空格。由雙字元指派運算子派生而得之單字元運算子分別為`!@\&，稱為雙字元派生單字元指派運算子。
002 在檢查開始時（如無特別指明則在一開始便完成）必須將雙字元運算子由+=至%=再由左而右轉換為相對應之派生單字元指派運算子。因此，以下檢查不再需要考慮雙字元指派運算子。
003 變數為符合變數命名規範之一個字串、數字為阿拉伯數字與其餘（排除運算子與變數）非空格符號組成之共同體。
004 一個運算子構成一個槽位、一個變數構成一個槽位、一個數字構成一個槽位。
005 空格必作為槽位分隔之用。
006 左邊右邊為鄰接之槽位，「範圍」指涉一段空間中的所有槽位。
007 變數名稱必須以命名空間規範的開頭字元為開頭（數字不得為開頭），名稱內可以包含命名空間的字元。
008 初始化的形式：尚未出現之名稱+等號指派（不可為雙字元派生單字元指派運算子）+有效數字。
009 運算子分群：
	加減階級符號：+ -
	乘除階級符號：* / %
	指數階級符號：
	左括號：(
	右括號：)
	指派符號：= += -= *= /= %=
010 無論派生與否，單、多字元運算子的命名空間不應與變數數字分隔符號重疊。多字元運算子若可視為某非派生單字元運算子的別名，則其派生單字元運算子的用字以與此非派生單字元運算子一致為優先。
011 若有分隔符號，則不該事先假設分隔符號與變數命名空間的交集為空集合，但分隔符號不該為數字。override
012 變數開頭字元與非開頭字元的差集合為變數開頭限定字元；非開頭字元與開頭字元的差集合為變數內容限定字元。
013 Common case之下的法則，必須與Common case享有相同的變數命名法則。

common case
無分隔符號（因為任何無關字元實際上都可以作為分隔用途）；加入單字元指數階級運算子^。
A00 字串處理(A00 A01)
	1.除了運算子（不含派生運算子）所使用到的字符、數字、變數命名空間、空格以外的符號都刪除。
		s/[^\w\$\s+\-*\/%^\(\)=]//g
	2.將雙元運算子轉換為派生單字元運算子。[[002]]
		s/\+=/`/g s/\-=/!/g s/\*=/@/g s/\/=/\\/g s/%=/&/g
	3.將每個運算子左右加上空格。
		s/([+\-*\/%^\(\)=`!@\\&])/ $1 /g，- / ( ) \ are escaped.
	4.隔開變數與數字：出現可作為變數名稱首字的字元時選取直到非變數內容字元為止，在左右加上空格。
		s/([A-Za-z_\$][\w\$]*)/ $1 /g
	5.若出現以非數字的內容限定字元為首的槽位，或者以數字為開頭的槽位中出現非數字內容限定字元，則為錯誤。（若內容限定字元只有數字則可忽略）
		"A00 error" if $s =~ /(?:^|\s)(?=[\d])(?=[^\d])|(?:^|\s)\d[^\s]*?(?=[^\d])(?=[\d])/
	6.將邊緣空格刪除、將內部的連續空格減小至一個
		s/^\s+|\s+$|([^\s]\s)\s+(?=[^\s])/$1$2/g
A01 不得只有空格。(A12)
	"A01 error" if $s !~ /[^\s]/
A02 首槽位若是運算子則只能是加減或左括號。(A02 A17-1)[[position]]
	"A02 error" if $s =~ /^[^\w\$+\-\(]/
A03 結尾槽不得放除右括號外的運算子。(A13 A17-done)[[position]]
	"A03 error" if $s =~ /[^\w\$\)]$/
A04 乘除階級或指數階級的符號左邊不得接「加減階級的符號、乘除階級的符號、指數階級的符號、左括號與指派符號」。(A03 A04 A05 A08 A15-done A16-1)[[position]]
	"A04 error" if $s =~ /[+\-*\/%^\(=`!@\\&]\s[*\/^]/
A05 右括號左邊不得出現除右括號外任何運算子。(A06 A14 A16-2)[[position]]
	"A05 error" if $s =~ /[^\w\$\)]\s[\)]/
A06 指派符號左邊不得有任何運算子。(A07 A09 A16-done)[[position]]
	"A06 error" if $s =~ /[^\w\$]\s[=`!@\\&]/
A07 在指派符號的左方範圍（到左方最靠近的左括號的下一字元開始選，若無左括號則從開頭選）出現的運算子只能是左括號或指派符號。(A11)[[position]] override
    也就是，若從開頭到指派符號的範圍出現了除左括號或指派符號之外的運算子，則此運算子與此指派符號之間必須存在左括號或指派符號。
	"A07 error" if $s =~ /[^\w\$\(=`!@\\&\s][^\(=`!@\\&]*?[=`!@\\&]/ or /[^\w\$\(=`!@\\&\s][^\(]*?[=`!@\\&]/
A08 在指派符號的左方範圍（到左方最靠近的左括號或指派符號的下一字元開始選，若無左括號或指派符號則從開頭選），範圍內不得出現數字，且變數必須有一個且僅有一個。(A10)[[position]] override
	1.不得出現數字。
	  也就是，若從開頭到指派符號的範圍出現了數字，則此數字與此指派符號之間必須存在左括號或指派符號。
		"A08 error-1" if $s =~ /(?:^|\s)\d[^\(=`!@\\&]*?[=`!@\\&]/ or /(?:^|\s)\d[^\(]*?[=`!@\\&]/
	2.變數必須有且僅有一個。
	  確保不會有兩個以上的變數，且已確保不得出現數字(A08-1)，且已確保指派符號左邊槽位必須有一個非運算子(A06)
		"A08 error-2" if $s =~ /(?:^|[\(=`!@\\&]\s)[A-Za-z_\$][\w\$\s]*?\s[A-Za-z_\$][\w\$\s]*?[=`!@\\&]/
A09 未宣告變數的（槽位必不在最後一個指派運算子右方的範圍，且其）右方必須是「非派生」單字元指派運算子。(A18 A19)
	while($s =~ /([A-Za-z_\$][\w\$]*?)(?=\s(.)|$)/g){
		#if($s2 is not in baseassignope and $s1 is not defined){say "A09 error";}
	}

原標準問題點：
a = b 0
a = 0 b --a b尚未定義。<del>與原標準相斥但無意間在實作上被容許的bug</del>這是實作中事先保留的52個已定義變數名稱之二，所以是不違反標準的。
a = b = 5 + ( c = 5 ) --與原標準相斥但實際上合理的表達。A07 override for

C-style case
加入分隔符號'。
B00 字串處理(B00 B01 B06)
	1.若出現除運算子（不含派生運算子）所使用到的字符、數字、變數命名空間、空格或分隔符號，則視為錯誤。
		"B00 error-1" if $s =~ /[^\w\$\s+\-*\/%\(\)=\']/
	2.將雙元運算子轉換為派生單字元運算子。[[002]]
		s/\+=/`/g s/\-=/!/g s/\*=/@/g s/\/=/\\/g s/%=/&/g
	3.將每個運算子左右加上空格。
		s/([+\-*\/%\(\)=`!@\\&])/ $1 /g，- / ( ) \ are escaped.
	4.若出現以非數字的內容限定字元為首的槽位，或者以數字為開頭的槽位中出現非數字內容限定字元，則為錯誤。（若內容限定字元只有數字則可忽略）[[deprecated]]
		以符合A00-5作為前提，如果分隔符號為內容限定字元，對出現在開頭的分隔符號另有規定規範。
		"B00 error-2" if $s =~ /(?:^|\s)(?=[\d])(?=[^\d])|(?:^|\s)\d[^\s]*?(?=[^\d])(?=[\d])/
	5.將邊緣空格刪除、將內部的連續空格減小至一個
		s/^\s+|\s+$|([^\s]\s)\s+(?=[^\s])/$1$2/g
B01 分隔符號處置(B09 B10 B11)
	1.若分隔符號出現在槽位開頭，若其非變數開頭字元則為錯誤。（若分隔符號可作為變數開頭字元則可忽略）（若分隔符號是變數字元，則與A00-5重複）
		"B01 error-1" if $s =~ /(?:^|\s)(?=[\'])(?=[^A-Za-z_\$])/
	2.若在變數槽位出現分隔字元，若其非變數內容字元則為錯誤。（若其為變數內容字元則可忽略）
		"B01 error-2" if $s =~ /(?:^|\s)[A-Za-z_\$][^\s]*?(?=[\'])(?=[^\w\$])/
	3.若在數字槽位出現分隔字元，則其左右必須皆為數字。
		"B01 error-3" if $s =~ /(?:^|\s)\d[^\s]*?(?:\d[\'](?=[^\d])|[^\d][\'])/
B02 左括號左邊若有槽位則必須是運算子。(B02)
	"B02 error" if $s =~ /[^+\-*\/%\(\)=`!@\\&]\s[\(]/
B03 右括號右方若有槽位則必須是運算子。(B03)
	"B03 error" if $s =~ /[\)]\s[^+\-*\/%\(\)=`!@\\&]/
B04 數字之間、變數之間、或數字與變數之間必須存在運算子。(B07)
	"B04 error" if $s =~ /[^+\-*\/%\(\)=`!@\\&]]\s[^+\-*\/%\(\)=`!@\\&]]/
--- 左括號不可出現在最後的槽位。(B12)[[deprecated]]
	與A03重複。
B05 左括號與右括號不得並列。(B08)
	"B05 error" if $s =~ /[\(]\s[\)]|[\)]\s[\(]/
B06 左右括號數量應該相等。(B04)
	"B06 error" if scalar @{[$s =~ /[\(]/g]} != scalar @{[$s =~ /[\)]/g]}
B07 右括號出現時至少有一個尚未配對的左括號。(B05)
	while($s =~ /[\)]/g){
		my $tmp = substr $s, 0, $-[0];
		if(scalar @{[$tmp =~ /[\(]/g]} <= scalar @{[$tmp =~ /[\)]/g]}){
			say "B07 error";
		}
	}
B08 不允許後方初始化。(B13)
	if($s =~ /[$assignope_regex]/){
		my $tmp = substr $s, $+[0];
		while($s =~ /([$varinit_regex][$varcontent_regex]*?)(?:\s|$)/g){
			#if($s1 is not defined){say "B08 error";}
		}
	}